# Ed25519

Ed25519 is the signature scheme being used in Cardano, and supported in
Plutus. Ed25519 is an instantiation of the EdDSA over the Edwards25519 elliptic curve.

## Implementation and bindings
We currently relly in the implementation available in version [1.0.18 of libsodium](https://github.com/jedisct1/libsodium/tree/1.0.18/src/libsodium/crypto_sign/ed25519/ref10). We have analysed, and recommend, bindings
in the following languages:
* Haskell: Available in [cardano-base](https://github.com/input-output-hk/cardano-base/blob/master/cardano-crypto-class/src/Cardano/Crypto/DSIGN/Ed25519.hs)
* Rust: Made [available](https://github.com/jedisct1/libsodium-sys-stable) by the original author of libsodium
* Javascript: Made [available](https://github.com/jedisct1/libsodium.js) by the original author of libsodium (among others)

There also exist other implementations that offer a compatible signing algorithm which do not require the full
usage of libsodium. The list we have analaysed and recommend is the following: 
* Rust: [ed25519-dalek](https://github.com/dalek-cryptography/ed25519-dalek), **using the `verify_strict()`** function.
* Javascript: [tweetnacl-js](https://github.com/dchest/tweetnacl-js), though the verification criteria of this library **is more permissive**,
  meaning that a valid signature for tweetnacl-js might not be valid for Cardano.

## Common mistakes
An ed25519 signature consists of two values $ (R,s) $, where $ R $ is an elliptic curve point
and $ s\in\mathbb{Z}_{\order} $ is a scalar. A common mistake when deserialising the scalar $ s $
is to compute it modulo $ \order $ in case that $ s $ is larger than $ \order $. This must be 
avoided, specifically in consensus critical scenarios. 

Another common mistake is what criteria to use when deserialising an elliptic curve point. If none
of the libraries listed above are used, the engineer should carefully read the [sections](#generalised-specification)
[below](#parameters-of-instantiation) to understand the details, and the verification criteria used
in Cardano.

## Generalised specification 
This section presents the generalized signature system EdDSA, and in the [parameter](#parameters-of-instantiation) section, we present the
specific parameters used in Cardano. EdDSA is parametrized with the following parameters. An integer $ b\geq 10 $, a
cryptographic hash function $ \hash $ producing a $ 2b $-bit output, and a finite abelian group based on an elliptic
curve. An EdDSA, signature consists of the following three algorithms:
* $ \keygen(1^\secparam) $ takes as input the security parameter $ \secparam $ and returns a key-pair $
(\secretkey, \vk)$. First, it chooses $ \secretkey\leftarrow\{0,1\}^b $. Next, let $ (h_0, h_1, \ldots, h_{2b - 1})
\gets\hash(\secretkey) $, and compute the signing key, $ \signingkey \gets 2^{b-2} + \sum_{3\leq i\leq b-3}2^i h_i $
. Finally, compute $ \vk \gets \signingkey \cdot \generator $, and return $ (\secretkey, \vk) $.
* $ \sign(\secretkey, \vk, m) $ takes as input a keypair $ (\secretkey, \vk) $ and a message $ m $, and returns a
signature $ \signature $. Let $ r \gets H(h_b, \ldots, h_{2b-1}, m) $, and interpret the result as a little-endian
integer in $ \{0,1,\ldots, 2^{2b}-1\} $. Let $ R \gets r\cdot\generator $, and $ S \gets (r + H(R, A, M)\cdot
\signingkey) \mod \order $. Return $ \signature \gets (R, S) $.
* $ \verify(m, \vk, \signature) $ takes as input a message $ m $, a verification key $ \vk $ and a signature
$ \signature $, and returns $ r\in\{\accept, \reject\} $ depending on whether the signature is valid or not. The algorithm
returns $ \accept $ if the following equation holds and $ \reject $ otherwise:
$$ S\cdot\generator = R + H(R, \vk, m)\cdot \vk. $$

## Parameters of instantiation
\label{sec:parameters}
In this section we set to describe the concrete instantiation of the algorithm presented above. Not only we describe
the Curves and Hash functions used, but we also specify how deserialization happens, as this results in important
differences of the acceptance criteria of valid signatures. The algorithm we use is Ed25519[^ed25519].
However, our implementation slightly differs in the deserialization criteria. The details are as follows:

* Parameter $b$: We set $b=256$
* Curve: We define the curve, and by consequence the finite prime order field, security parameter, cofactor,
prime order subgroup and generator. In particular, we use Edwards25519 which
is birationally equivalent to Curve25519[^curve25519].
* Hash: As a hashing algorithm we use SHA512.
* Deserialization: A signature is represented by 64 bytes: the first 32 bytes, $b_{[..32]}$, represent the
point $R$, and the final 32 bytes, $b_{[32..]}$, represent the scalar $S$. A public key is also represented as 32
bytes, $b_{pk}$. Deserialization is valid only if:
  * $b_{[32..]}$, read as a little-endian integer, is smaller than $\order$.
  * $b_{[..32]}$ does not represent a low order point (by checking against a precomputed blacklist of size
  $\cofvar$).
  * $b_{pk}$ does not represent a low order point (by checking against a precomputed blacklist of size
  $\cofvar$), and when read as a little-endian integer, it is smaller than $p$.

[^ed25519]: Bernstein, Duif, Lange, Schwabe and Yang, _High-Speed High-Security Signatures_
[^curve25519]: Bernstein, _Curve25519: New Diffie-Hellman Speed Records_
