\section{Ed25519}
\label{sec:ed25519}

\subsection{Summary}
Ed25519 is the signature scheme being used in Cardano, and what is currently (as per 14th January 2022) supported in
Plutus. Ed25519 is an instantiation of the EdDSA over the elliptic curve Edwards25519, which is in turn closely
related to Schnorr signatures.

\subsection{Generalised specification}
This section presents the generalized signature system EdDSA, and in Section~\ref{sec:parameters}, we present the
specific parameters used in Cardano. EdDSA is parametrized with the following parameters. An integer $b\geq 10$, a
cryptographic hash function $\hash$ producing a $2b$-bit output, and a finite abelian group based on an elliptic
curve. An EdDSA signature consists of the following three algorithms:
\begin{itemize}
    \item $\keygen(1^\secparam)$ takes as input the security parameter $\secparam$ and returns a key-pair $
    (\secretkey, \vk)$. First, it chooses $\secretkey\leftarrow\{0,1\}^b$. Next, let $(h_0, h_1, \ldots, h_{2b - 1})
    \gets\hash(\secretkey)$, and compute the signing key, $\signingkey \gets 2^{b-2} + \sum_{3\leq i\leq b-3}2^i h_i$
    . Finally, compute $\vk \gets \signingkey \cdot \generator$, and return $(\secretkey, \vk)$.
    \item $\sign(\secretkey, \vk, m)$ takes as input a keypair $(\secretkey, \vk)$ and a message $m$, and returns a
    signature $\signature$. Let $r \gets H(h_b, \ldots, h_{2b-1}, m)$, and interpret the result as a little-endian
    integer in $\{0,1,\ldots, 2^{2b}-1\}$. Let $R \gets r\cdot\generator$, and $S \gets (r + H(R, A, M)\cdot
    \signingkey) \mod \order$. Return $\signature \gets (R, S)$.
    \item $\verify(m, \vk, \signature)$ takes as input a message $m$, a verification key $\vk$ and a signature
    $\signature$, and returns $r\in\{true, false\}$ depending on whether the signature is valid or not. The algorithm
    returns $true$ if the following equation holds and $false$ otherwise:
    \[S\cdot\generator = R + H(R, \vk, m)\cdot \vk.\]
\end{itemize}

\subsection{Parameters of instantiation}
\label{sec:parameters}
In this section we set to describe the concrete instantiation of the algorithm presented above. Not only we describe
the Curves and Hash functions used, but we also specify how deserialization happens, as this results in important
differences of the acceptance criteria of valid signatures. The algorithm we use is Ed25519~\cite{CHES:BDLSY11}.
However, our implementation slightly differs in the deserialization criteria. The details are as follows:
\begin{description}
    \item[Parameter $b$:] We set $b=256$
    \item[Curve:] We define the curve, and by consequence the finite prime order field, security parameter, cofactor,
    prime order subgroup and generator, as described in~\cite{CHES:BDLSY11}. In particular, we use Edwards25519 which
    is birationally equivalent to Curve25519~\cite{PKC:Bernstein06}.
    \item[Hash:] As a hashing algorithm we use SHA512~\cite{FIPS1802}.
    \item[Deserialization:] A signature is represented by 64 bytes: the first 32 bytes, $b_{[..32]}$, represent the
    point $R$, and the final 32 bytes, $b_{[32..]}$, represent the scalar $S$. A public key is also represented as 32
    bytes, $b_{pk}$. Deserialization is valid only if:
    \begin{itemize}
        \item $b_{[32..]}$, read as a little-endian integer, is smaller than $\order$.
        \item $b_{[..32]}$ does not represent a low order point (by checking against a precomputed blacklist of size
        $\cofvar$.
        \item $b_{pk}$ does not represent a low order point (by checking against a precomputed blacklist of size
        $\cofvar$, and when read as a little-endian integer, it is smaller than $p$.
    \end{itemize}
\end{description}

\subsection{External links}
We currently rely in the implementation available in version \href{https://github.com/jedisct1/libsodium/tree/1.0
.18/src/libsodium/crypto_sign/ed25519/ref10}{1.0.18 of libsodium}. For Jormungandr we use a \href{https://docs
.rs/cryptoxide/latest/cryptoxide/ed25519/index.html}{Rust implementation}. However, note that this implementation
does not check if $b_{[..32]}$ has low order, or if $b_{pk}$ is canonical. This means that the verification criteria
for Jormungander is currently different to that of Cardano.
