\section{Ed25519}
\newcommand{\keygen}{\texttt{KeyGen}}
\newcommand{\sign}{\texttt{Sign}}
\newcommand{\verify}{\texttt{Verify}}
\newcommand{\secparam}{\lambda}
\newcommand{\secretkey}{x}
\newcommand{\signingkey}{sk}
\newcommand{\vk}{vk}
\newcommand{\signature}{\sigma}


\newcommand{\ec}{E}
\newcommand{\cofvar}{\texttt{cofvar}}
\newcommand{\group}{\mathbf{G}}
\newcommand{\generator}{G}
\newcommand{\order}{q}
\newcommand{\hash}{\texttt{H}}

\subsection{Summary}
Ed25519 is the signature scheme being used in Cardano, and what is currently (as per 14th January 2022) supported in Plutus. Ed25519 is an instantiation of the EdDSA over the elliptic curve Edwards25519, which is in turn closely related to Schnorr signatures. 
\subsection{Generalised specification}
This section presents the generalized signature system EdDSA, and in Section~\ref{sec:parameters}, we present the specific parameters used in Cardano. EdDSA is parametrized with the following parameters. An integer $b\geq 10$, a cryptographic hash function $\hash$ producing a $2b$-bit output, a finite abelian group based on an elliptic curve, $\ec(\mathbb{F}_p)$, over a finite prime-order field $\mathbb{F}_p$ (note that we simplify the notation and drop the explicit dependency on $\mathbb{F}_p$ and security parameter $\kappa$). Most importantly, we assume the order of the group $\ec$ to be of the form $\cofvar\cdot \order$ for some small \emph{cofactor} $\cofvar$ and large prime number $\order$, and that the (hence) unique subgroup $\group$ of order $\order$ is generated by a known base point $\generator$, i.e., $\group = \langle\generator\rangle$,  in which the computational Diffie-Hellman (CDH) problem is believed to be hard. An EdDSA signature consists of the following three algorithms: 
\begin{itemize}
\item $\keygen(1^\secparam)$ takes as input the security parameter $\secparam$ and returns a key-pair $(\secretkey, \vk)$. First, it chooses $\secretkey\leftarrow\{0,1\}^b$. Next, let $\hash(\secretkey) = (h_0, h_1, \ldots, h_{2b - 1})$, and compute the signing key, $\signingkey = 2^{b-2} + \sum_{3\leq i\leq b-3}2^i h_i$. Finally, compute $\vk = \signingkey \cdot \generator$, and return $(\secretkey, \vk)$. 
\item $\sign(\secretkey, \vk, m)$ takes as input a keypair $(\secretkey, \vk)$ and a message $m$, and returns a signature $\signature$. Let $r = H(h_b, \ldots, h_{2b-1}, m)$, and interpret the result as a little-endian integer in $\{0,1,\ldots, 2^{2b}-1\}$. Let $R = r\cdot\generator$, and $S = (r + H(R, A, M)\cdot \signingkey) \mod \order$. Return $\signature = (R, S)$. 
\item $\verify(m, \vk, \signature)$ takes as input a message $m$, a verification key $\vk$ and a signature $\signature$, and returns $r\in\{true, false\}$ depending on whether the signature is valid or not. The algorithm returns $true$ if the following equation holds and $false$ otherwise: 
\[S\cdot\generator = R + H(R, \vk, m)\cdot \vk.\]
\end{itemize}

\subsection{Parameters of instantiation}
\label{sec:parameters}
\textit{This section covers the details of the primitive. It should cover all that is required for an external observer to implement a compatible version without needing to look into the code. This should cover, the curve parameters, hashing algorithms, format, serialisation/deserialisation mechanisms, etc.}

\subsection{External links}
\textit{Links of interest, such as papers, gdocs, jira pages, etc.}