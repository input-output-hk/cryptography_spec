\section{Verifiable Random Functions}
\subsection{Summary}
\newcommand{\sk}{sk}
\newcommand{\vrf}{\texttt{VRF}\xspace}
\newcommand{\vrfsk}{\sk_{\vrf}}
\newcommand{\vrfvk}{\vk_{\vrf}}
\newcommand{\vrfoutput}{\beta}
\newcommand{\vrfproof}{\Pi}
\newcommand{\vrfkeygen}{\texttt{VrfKeyGen}}
\newcommand{\vrfgenerateproof}{\texttt{GenerateProof}}
\newcommand{\parallelsep}{\;||\;}
\newcommand{\true}{\texttt{true}}
\newcommand{\false}{\texttt{false}}


Verifiable Random Functions (\vrf) allow key-pair owners, $(\vrfsk, \vrfvk)$,
to evaluate a pseudorandom function in a provable way given a randomness seed.
Any party with access to the verification key, $\vrfvk$, the
randomness seed, the proof and the generated randomness can indeed verify
that the value is computed as expected. The VRF specification has changed
overtime in Cardano, and the nodes use a different algorith, pre-Babbage and
post-Babbage (if there exists a reference to the HF, we should point it out).
We expose both specifications, and the motivations for such a change.
\subsection{Generalised specification}
We denote by $\ec(\mathbb{F}_p)$ the finite abelian group based on an elliptic curve over a finite prime-order field $\mathbb{F}_p$ (note that we simplify the notation and drop the explicit dependency on $\mathbb{F}_p$ and security parameter $\kappa$). Most importantly, we assume the order of the group $\ec$ to be of the form $\cofvar\cdot \order$ for some small \emph{cofactor} $\cofvar$ and large prime number $\order$, and that the (hence) unique subgroup $\group$ of order $\order$ is generated by a known base point $\generator$, i.e., $\group = \langle\generator\rangle$,  in which the computational Diffie-Hellman (CDH) problem is believed to be hard.

We use $\hash$ to denote a cryptographically safe hash function, modeled as a random oracle, $\hash: \{0,1\}^*\rightarrow\{0,1\}^{\ell(\kappa)}$. We use another hash function that outputs an element in $\group$, $\hash_{s2c}: \{0,1\}^* \to \group$.

A \vrf function, in pre-Babbage eras, is defined by the following three algorithms:
\begin{itemize}
\item $\vrfkeygen(1^\secparam)$ follows the exact same procedure as $\keygen(1^\secparam)$ described in Ed25519, see Section~\ref{sec:ed25519}. Output key pair $(\secretkey, \vrfvk)$. We refer to the signing key $\signingkey$ in the Ed25519 section as $\vrfsk$.
\item $\vrfgenerateproof(\secretkey, \vrfvk, m)$ takes as input a keypair $(\secretkey, \vrfvk)$ and a message $m$, and returns the \vrf randomness $\vrfoutput$ together with a proof $\vrfproof$. Use $\secretkey$ to derive $\vrfsk$. Let $H \gets \hash_{s2c}(\vrfvk, m)$. Let $\Gamma \gets \vrfsk\cdot H$. Compute $r$ as defined in procedure $\sign$ from Section~\ref{sec:ed25519}. Let $c \gets \hash(H\parallelsep\Gamma\parallelsep k\cdot\generator\parallelsep k\cdot H)[..128]$. Compute $s \gets (r + c\cdot\vrfsk)\mod\order$. Finally, return the proof $\vrfproof \gets (\Gamma, c, s)$ and the randomness $\vrfoutput \gets \hash(\texttt{suite\_string}\parallelsep 0x03\parallelsep\cofvar\cdot\Gamma\parallelsep 0x00)$.
\item $\verify(m, \vrfvk, \vrfproof)$ takes as input a message $m$, a verification key $\vrfvk$ and a vrf proof $\vrfproof$, and returns $\vrfoutput$ or \false. It parses the proof as $(\Gamma, c, s) = \vrfproof$, and computes $H\gets\hash_{s2c}(\vrfvk, m)$. Let $U \gets s\cdot\generator - c\cdot\vrfvk$ and $V \gets s\cdot H - c\cdot\Gamma$. Compute the challenge $c'\gets\hash(H\parallelsep\Gamma\parallelsep U\parallelsep V)[..128]$. If $c'=c$, then return $\vrfoutput \gets  \hash(\texttt{suite\_string}\parallelsep 0x03\parallelsep\cofvar\cdot\Gamma\parallelsep 0x00)$, otherwise, return \false.
\end{itemize}

A \vrf function, in post-Babbage eras, is defined by the following three algorithms:
\begin{itemize}
\item $\vrfkeygen(1^\secparam)$ follows the exact same procedure as $\keygen(1^\secparam)$ described in Ed25519, see Section~\ref{sec:ed25519}. Output key pair $(\secretkey, \vrfvk)$. We refer to the signing key $\signingkey$ in the Ed25519 section as $\vrfsk$.
\item $\vrfgenerateproof(\secretkey, \vrfvk, m)$ takes as input a keypair $(\secretkey, \vrfvk)$ and a message $m$, and returns the \vrf randomness $\vrfoutput$ together with a proof $\vrfproof$. Use $\secretkey$ to derive $\vrfsk$. Let $H \gets \hash_{s2c}(\vrfvk, m)$. Let $\Gamma \gets \vrfsk\cdot H$. Compute $r$ as defined in procedure $\sign$ from Section~\ref{sec:ed25519}. Let $c \gets \hash(H\parallelsep\Gamma\parallelsep k\cdot\generator\parallelsep k\cdot H)$. Compute $s \gets (r + c\cdot\vrfsk)\mod\order$. Finally, return the proof $\vrfproof \gets (\Gamma, k\cdot\generator, k\cdot H, s)$ and the randomness $\vrfoutput \gets  \hash(\texttt{suite\_string}\parallelsep 0x03\parallelsep\cofvar\cdot\Gamma\parallelsep 0x00)$.
\item $\verify(m, \vrfvk, \vrfproof)$ takes as input a message $m$, a verification key $\vrfvk$ and a vrf proof $\vrfproof$, and returns $\vrfoutput$ or \false. It parses the proof as $(\Gamma, U, V, s) = \vrfproof$, and computes $H\gets\hash_{s2c}(\vrfvk, m)$. Next, compute $c \gets \hash(H\parallelsep\Gamma\parallelsep k\cdot\generator\parallelsep k\cdot H)[..128]$. Finally, if $U = s\cdot\generator - c\cdot\vrfvk$ and $V = s\cdot H - c\cdot\Gamma$, then return $\vrfoutput =  \hash(\texttt{suite\_string}\parallelsep 0x03\parallelsep\cofvar\cdot\Gamma\parallelsep 0x00)$, otherwise, return \false.
\end{itemize}

This change allows for batch verification of proofs, which achieve up to a times two improvement in verification time, in exchange of a larger proof.
\subsection{Parameters of instantiation}
Some of the concrete parameter instantiations also differ between pre-Babbage and post-Babbage eras. We begin by describing those which coincide, and folow with a separate description for the ones that differ.
\begin{description}
\item[Parameter $\ell(\kappa)$ and suite $\texttt{suite\_string}$:] We set $\ell(\kappa)=512$. We choose the suite \texttt{ECVRF\_EDWARDS25519\_SHA512\_ELL2}, as defined in the standard draft~\cite{vrfdraft}. This sets the parameter $\texttt{suite\_string}$ as $0x04$ and the following parameters.
\item[Curve:] We define the curve, and by consequence the finite prime order field, security parameter, cofactor, prime order subgroup and generator, as described in~\cite{CHES:BDLSY11}. In particular, we use Edwards25519 which is birationally equivalent to Curve25519~\cite{PKC:Bernstein06}.
\item[Hash:] As a hashing algorithm we use SHA512~\cite{FIPS1802}.
\end{description}

We proceed with the specifications on pre-Babbage eras.
\begin{description}
\item[Draft version:] pre-Babbage eras are build on top of Version 03 of the standards draft~\cite{vrfdraft}.
\item[Deserialization:] A \vrf proof is represented by 80 bytes: the first 32 bytes, $b_{[..32]}$, represent the point $\Gamma$, the following 16 bytes, $b_{[32..48]}$, represent the scalar $c$, and the final 32 bytes, $b_{[48..]}$, represent the scalar $s$. A public key is also represented as 32 bytes, $b_{pk}$. Deserialization is valid only if:
\begin{itemize}
\item $b_{[..32]}$ when read as a little-endian integer, it is smaller than $p$.
\item $b_{pk}$ does not represent a low order point (by checking against a precomputed blacklist of size $\cofvar$, and when read as a little-endian integer, it is smaller than $p$.
\end{itemize}
\item[Hash to curve $\hash_{s2c}$:]
\end{description}

We finalize with the specifications of post-Babbage eras.
\begin{description}
\item[Draft version:] post-Babbage eras are build on top of a batch-compatible version of  Version 10 of the standards draft~\cite{vrfdraft}.
\item[Deserialization:] A \vrf proof is represented by 128 bytes: the first 32 bytes, $b_{[..32]}$, represent the point $\Gamma$, the following 32 bytes, $b_{[32..64]}$, represent the point $U$, the following 32 bytes, $b_{[64..96]}$, represent the point $V$, and the final 32 bytes, $b_{[96..]}$, represent the scalar $s$. A public key is also represented as 32 bytes, $b_{pk}$. Deserialization is valid only if:
\begin{itemize}
\item $b_{[..32]}$ when read as a little-endian integer, it is smaller than $p$.
\item $b_{[96..]}$ when read as a little-endian integer, is smaller than $\order$.
\item $b_{pk}$ does not represent a low order point (by checking against a precomputed blacklist of size $\cofvar$, and when read as a little-endian integer, it is smaller than $p$.
\end{itemize}
\item[Hash to curve $\hash_{s2c}$:]
\end{description}
\subsection{External links}
\printbibliography[heading=subbibintoc]
\textit{Links of interest, such as papers, gdocs, jira pages, etc.}
